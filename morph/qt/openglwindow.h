/*
 * Set up an OpenGL-enabled window for OpenGL content generated by morph::Visual.  This
 * needs to provide just enough set up for morph::Visual to render. That means creating
 * an OpenGL context and getting the OpenGL system initialised so that morph::Visual can
 * compile shader programs.
 *
 * Adapted from the tutorial material from The Qt Company Ltd. with a licence notice
 * reproduced at the end of the file.
 *
 * Adaptation: Seb James
 * Date: July 2023
 */

#include <QtGui/QWindow>
#include <QOpenGLFunctions_4_1_Core>
#include <QtCore/QCoreApplication>
#include <QOpenGLContext>
#include <QOffscreenSurface>
#include <QSurfaceFormat>
#include <iostream>

namespace morph {
    namespace qt {

        class OpenGLWindow : public QWindow, protected QOpenGLFunctions_4_1_Core
        {
            Q_OBJECT
        public:
            explicit OpenGLWindow (QWindow *parent = 0)
                : QWindow(parent)
                , m_update_pending (false)
                , m_animating (false)
                , m_context(0)
            {
                std::cout << "OpenGLWindow(QWindow*) constructor\n";
                setSurfaceType (QWindow::OpenGLSurface);
                this->format.setDepthBufferSize (4);
                this->format.setSamples (24);
                this->format.setVersion (4, 1);
                this->format.setRenderableType (QSurfaceFormat::OpenGL);
                this->format.setProfile (QSurfaceFormat::CoreProfile);
                this->setFormat (this->format);
                this->initialize();
            }

            ~OpenGLWindow() {}

            virtual void render (QPainter *painter) { Q_UNUSED (painter); }
            virtual void render() { std::cout << "OpenGLWindow::render()\n"; }

            virtual void initialize()
            {
                if (!m_context) {
                    m_context = new QOpenGLContext(this);
                    m_context->setFormat(requestedFormat());
                    m_context->create();
                }
                // During init we need an off-screen surface (because the screen hasn't been created yet).
                QOffscreenSurface* offsurface = new QOffscreenSurface;
                offsurface->setFormat (requestedFormat());
                offsurface->create();
                m_context->makeCurrent (offsurface);
                // Now we can initializeOpenGLFunctions(). This will then allow morph::Visual to compile shaders.
                initializeOpenGLFunctions();
                std::cout << "OpenGLWindow::initialize() returning\n";
            }

            // The 'animating' feature is unlikely to be required with morphologica, but leave it for now
            void setAnimating (bool animating)
            {
                m_animating = animating;
                if (animating) { renderLater(); }
            }

            // Set the context to this window
            void setContext() { m_context->makeCurrent (this); }

            void swapBuffers() { m_context->swapBuffers (this); }

        public slots:
            void renderLater()
            {
                std::cout << "OpenGLWindow::renderLater() called" << std::endl;
                if (!m_update_pending) {
                    m_update_pending = true;
                    QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest));
                }
            }

            void renderNow()
            {
                std::cout << "OpenGLWindow::renderNow() called" << std::endl;
                if (!isExposed()) { return; }
                this->render(); // Should call back to Visual::render()
                if (m_animating) { renderLater(); }
            }

        protected:
            bool event (QEvent* event) override
            {
                switch (event->type()) {
                case QEvent::UpdateRequest:
                {
                    m_update_pending = false;
                    renderNow();
                    return true;
                }
                default: { return QWindow::event(event); }
                }
            }

            void exposeEvent (QExposeEvent* event) override
            {
                Q_UNUSED(event);
                if (isExposed()) { renderNow(); }
            }


        private:
            bool m_update_pending;
            bool m_animating;
        protected:
            QOpenGLContext *m_context;
            QSurfaceFormat format;
        };

    } // namespace qt
} // namespace morph

/*
 * This file was adapted from Qt example documentation:
 *
 * Copyright (C) 2015 The Qt Company Ltd.
 * Contact: http://www.qt.io/licensing/
 *
 * This file is part of the documentation of the Qt Toolkit.
 *
 * You may use this file under the terms of the BSD license as follows:
 *
 * "Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in
 * the documentation and/or other materials provided with the
 * distribution.
 * * Neither the name of The Qt Company Ltd nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
 */
