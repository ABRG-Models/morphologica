---
title: Why was morphologica developed?
parent: Welcome
layout: page
permalink: /why
nav_order: 3
---
# Why build it?

Why did I expend the time writing an OpenGL visualization system for C++ when there were alternatives, already available?

First, understand that I was writing numerical programs that I wanted to *visualize during runtime* and consider the alternatives. Most of the world makes graphs with [Python](https://www.python.org) (usually with [matplotlib](https://matplotlib.org/)) or [MATLAB](https://uk.mathworks.com/products/matlab.html).
There are many similar systems like [GNU Octave](https://octave.org/) and [R](https://www.r-project.org/about.html) and its plotting library [ggplot](https://ggplot2.tidyverse.org/). Many people use stand-alone graphing packages like [Veusz](https://veusz.github.io/) to view data generated by another program (I used the venerable [Grace](https://plasma-gate.weizmann.ac.il/Grace/) this way to plot graphs for my PhD).
They all work. You can plot 2D graphs and 3D graphs with all of these systems and they generate publication quality output. However, in the case of the language based systems (matplotlib/Python, MATLAB, R/gglplot) you are tied to a particular programming language and for the stand-alone programs, you have to build a run-save-graph workflow.

With this understanding, I think the reasons I started morphologica were *preference*, *benefit* and *opportunity*.

*Preference*, because I really prefer to visualize during runtime (so the graph-after-running approach was out)  and I just don't really like Python or MATLAB very much. I dislike Python's lack of scope identifiers, which make it awkward to copy blocks of code around and I find the management of Python packages a headache. I failed to get on with MATLAB which always felt unwieldy, though I still use the much lighter GNU Octave for quick plotting jobs, as the 'workspace' approach is convenient.

On the other hand, I do really like C++, especially with the changes made in the C++-17 and C++-20 revisions of the language. I find modern C++ expressive and powerful. However, there was a lack of good (meaning light, fast and easy to use) graphing and data visualization libraries for C++ which hampered my preference for building runtime visualization in C++.

I could see that data visualization written in C++ and based on computer gaming technology had the promise of being lightning fast with minimal use of computational resources. I wanted a visualization system like this so that I could have insightful graphics while still getting the most I possilbly could out of the CPU hardware I had access to. There was a clear *benefit* to be had by developing morphologica.

When I started a project in 2018 at the University of Sheffield with [Stuart Wilson](https://www.linkedin.com/in/stuart-wilson-83a4582b/) in which we needed to solve reaction-diffusion equations, I was given the *opportunity*. There was a requirement to plot the results of those computations and Stuart had already been using OpenGL 2 code to do this. I had a free hand in how to go about the work and plenty of time on a 4 year project to redesign a new library using modern, shader-based OpenGL techniques.

Could I have used an alternative C++ plotting system? Possibly. Alternatives do exist, and they include CERN's [Root](https://root.cern/), (ugly graphs, too complex), [VTK](https://vtk.org/) from Kitware, (too big, too complex) and [matplot++](https://alandefreitas.github.io/matplotplusplus/), which copies the Python matplotlib API which I never got on with! I wasn't enticed by any of these libraries and I was soon drawing OpenGL triangles all over my screen instead!

Now, after more than five years of development, morphologica has become a mature library of code which is lightweight, very easy to incorporate into projects and which can animate 3D plots with very low CPU overhead. It was worth the effort!

[Seb James](https://www.linkedin.com/in/sebjames/), January 2024